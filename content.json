{"meta":{"title":"ReverieZH","subtitle":null,"description":null,"author":"ReverieZh","url":"https://ReverieZh.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2019-10-30T08:36:49.000Z","updated":"2020-02-20T15:52:20.272Z","comments":false,"path":"categories/index.html","permalink":"https://ReverieZh.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"Redis基础学习","date":"2020-02-22T10:29:06.067Z","updated":"2020-02-22T10:29:20.035Z","comments":true,"path":"2020/02/22/Redis基础学习/","link":"","permalink":"https://ReverieZh.github.io/2020/02/22/Redis基础学习/","excerpt":"","text":"RedisRedis（全称：Remote Dictionary Server 远程字典服务）是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。是一款NOSQL系列的非关系型数据库 对于key-value的非关系数据库是比较适合做缓存的。那么Redis有什么用。比如当数据库中的某些数据是不经常改变的，这时就可以将这些数据存入到缓存中。当客户端读取数据时，可以直接从缓存中读取。从而减少了对数据库的访问。 Redis做缓存的流程和计算机的缓存差不多。当第一次查询数据时，发现缓存中没有数据，便从数据库读取数据。当从数据库读取到数据之后，将数据存入到redis中。下次读取数据时，便从redis缓存中直接读取 Redis是一个key-value型数据库，value所支持的类型有1.string类型2.hashmap类型3.list类型4.set类型5.sortedset类型(有序集合) 环境搭建http://www.redis.net.cn/ 官网下载https://github.com/microsoftarchive/redis/releases github下载地址 redis.windows.conf：配置文件redis-cli.exe：redis的客户端redis-server.exe：redis服务器端redis-benchmark:Redis性能测试工具redis-stat:Redis状态检测工具 服务端窗口客户端窗口 命令操作1.通用命令1keys * 查询所有的建 1type key 获取建所对的值的数据类型 1del key 删除指定的key 2.字符串类型1).存储数据 1set key value key是键名value是值 2).获取数据 1get key value 3).删除数据 1del key hashmap类型1).存储数据 1hset key field value key是键名field 是map的键名value是值 2).获取数据 1hget key field 获取Map中的某一个键的值 1hgetall key 获取map的所有键和值 3).删除数据 1hdel key field 删除map中的某一个field list类型可以从列表的头部或者尾部插入或删除1).插入数据 1lpush key value 从左边插入数据 1rpush key value 从右边插入数据插入时注意不能和之前的其他数据类型的key重复 2).获取数据 1lrange key start end 获取某一范围到某一范围的值，获取全部start为0，end为03).删除数据 1lpop key 删除列表最左边的元素，并将元素返回 1rpop key 删除列表最右边的元素，并将元素返回 set集合set集合存储数据不允许重复元素1).存储数据 1sadd key value 插入数据到set集合中，若有相同数据不做操作2).获取数据 1smembers key 获取set集合的所有元素3).删除数据 1srem key value 删除set中的某一个值 sortedset类型sortedset是有序集合每个元素都会关联一个分数，来决定这排序顺序。redis通过分数进行从小到大排序1).添加数据 1zadd key score value 添加一个数据到sorted set中score是分数，它决定着排序的顺序。可以重复 2).获取数据 1zrange key start end [withscores] 获取start到end范围内的元素 withscores表示是否在查询的时候携带值 3).删除数据 1zrem key value 持久化redis是一个内存数据库，当redis的服务器重启时，数据会丢失之前存入的数据全部丢失所以就需要持久化机制将redis内存中的数据存入硬盘中 redis持久化机制1.RDB：默认的持久化方式。它的方式是在一定的时间内检测key的变化情况，然后持久化数据到硬盘中2.AOF:日志记录方式 1.RDB方式1).编辑redis.windwos.conf 有三个save比如save 60 10000 表示着60秒后又10000个key发生变化时会持久化一次 假如更改为2).重启redis服务器 打开cmdredis-server.exe redis.windows.conf以配置文件的方式启动服务器3).存入数据15秒后文件夹下回多出一个dump.rdb文件，这里就存在持久化的数据 4)测试直接关闭服务器，再直接打开服务器 在客户端查询数据获取成功 2.AOF方式日志记录的方式可以记录每一条命令的操作可以每一次命令操作后，持久化数据 1).编辑redis.windwos.conf文件appendonly no：关闭aofappendonly yes ：开启aof更改为yesappendfsync always ： 每一次操作都进行持久化appendfsync everysec ： 每隔一秒进行一次持久化appendfsync no ： 不进行持久化 2).重启服务器 打开cmdredis-server.exe redis.windows.conf以配置文件的方式启动服务器3).存入数据文件夹下会多出一个aof的文件 4).测试直接关闭服务器，再打开服务器通过redis-server.exe redis.windows.conf以配置文件的方式启动服务器 在客户端查询数据 java使用redis1).环境搭建java中使用redis需要导入Jedis的jar包 2)测试 123456789@Test public void test()&#123; Jedis jedis=new Jedis(); jedis.set(\"username\",\"kryie\"); jedis.set(\"password\",\"123\"); String username = jedis.get(\"username\"); System.out.println(username); &#125; java和redis客户端都可以获取到 操作数据1Jedis jedis=new Jedis(); 先创建Jedis对象操作数据通过Jedis对象调用方法，操作数据的方法和输入命令的命令名一致的 1).操作字符串123456789101112@Test public void testString()&#123; Jedis jedis=new Jedis(); jedis.set(\"username\",\"kryie\"); jedis.set(\"password\",\"123\"); String username = jedis.get(\"username\"); System.out.println(username);jedis.close(); &#125; 存入指定过期时间可以通过setex()方法 1jedis.setex(\"username\",60*60*24,\"curry\"); 第二个参数是过期时间，单位是秒 1jedis.del(\"username\"); 删除数据 2).操作hashmap存入数据和获取数据 123456789101112@Test public void testHash()&#123; Jedis jedis=new Jedis(); jedis.hset(\"myhash\",\"name\",\"zhangsan\"); jedis.hset(\"myhash\",\"age\",\"10\"); String name = jedis.hget(\"myhash\", \"name\"); System.out.println(name); jedis.close(); &#125; 获取全部 12345 Map&lt;String, String&gt; myhash = jedis.hgetAll(\"myhash\"); for (String key:myhash.keySet()) &#123; System.out.println(myhash.get(key));&#125; 删除数据 1jedis.hdel(\"myhash\",\"name\"); 3)操作list存入和获取数据 123456789101112@Test public void testList()&#123; Jedis jedis=new Jedis(); jedis.lpush(\"mylist\",\"r\"); jedis.lpush(\"mylist\",\"e\"); jedis.rpush(\"mylist\",\"y\"); List&lt;String&gt; mylist = jedis.lrange(\"mylist\", 0, -1); System.out.println(mylist); &#125; 删除数据 123String e1 = jedis.lpop(\"mylist\"); String e2 = jedis.lpop(\"mylist\"); String e3 = jedis.rpop(\"mylist\"); 4)操作set123456789101112@Test public void testSet()&#123; Jedis jedis=new Jedis(); //添加数据 jedis.sadd(\"myset\",\"name\",\"lisi\"); jedis.sadd(\"myset\",\"sex\",\"男\"); //获取数据 Set&lt;String&gt; myset = jedis.smembers(\"myset\"); System.out.println(myset); //删除数据 jedis.srem(\"myset\", \"name\")); &#125; 5).操作sortedset123456789101112@Test public void testSortedSet()&#123; Jedis jedis=new Jedis(); //添加数据 jedis.zadd(\"mysort\",50,\"wangwu\"); jedis.zadd(\"mysort\",60,\"zhangliu\"); //获取数据 Set&lt;String&gt; mysort = jedis.zrange(\"mysort\", 0, -1); System.out.println(mysort); //删除数据 jedis.zrem(\"mysort\",\"wangwu\"); &#125; JedisPooljedis的连接池 1234567891011121314@Test public void testJedisPool()&#123; //获取连接池 JedisPool pool=new JedisPool(); //从连接池获取Jedis Jedis jedis = pool.getResource(); //C存入数据 jedis.set(\"username\",\"xiaoming\"); //获取数据 String username = jedis.get(\"username\"); System.out.println(username); //关闭 jedis.close(); &#125; jedis.close()关闭，将jedis归还到连接池中 配置连接池 12345678JedisPoolConfig config=new JedisPoolConfig();config.setMaxIdle(10); //最大空闲数config.setMaxTotal(50); //最大连接数JedisPool jedisPool=new JedisPool(config,\"localhost\",6379);//指定配置类，主机和端口 JedisPoolConfig连接池的配置类","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://ReverieZh.github.io/categories/JavaEE/"},{"name":"Redis","slug":"JavaEE/Redis","permalink":"https://ReverieZh.github.io/categories/JavaEE/Redis/"}],"tags":[]},{"title":"","slug":"SpringMvc基础学习","date":"2020-02-22T04:46:18.754Z","updated":"2020-02-22T04:53:17.772Z","comments":true,"path":"2020/02/22/SpringMvc基础学习/","link":"","permalink":"https://ReverieZh.github.io/2020/02/22/SpringMvc基础学习/","excerpt":"SpringMVC MVC模式MVC是Model,View和Controller的缩写模型：用于存储数据以及处理用户请求的业务逻辑视图：向控制器提交数据，显示模型中的数据控制器：根据视图提出的请求判断请求和数据交给哪个模型处理，将处理后的有关结果交给哪个视图更新显示","text":"SpringMVC MVC模式MVC是Model,View和Controller的缩写模型：用于存储数据以及处理用户请求的业务逻辑视图：向控制器提交数据，显示模型中的数据控制器：根据视图提出的请求判断请求和数据交给哪个模型处理，将处理后的有关结果交给哪个视图更新显示 基于Servlet的MVC模式模型：一个或多个javaBean对象视图：一个或多个JSP页面控制器：一个或多个Servlet对象 SpringMVC工作原理 Spring核心组件DispatcherServlet : 前端控制器,接收所有请求(不包含jsp)HandlerMapping: 解析请求格式的.判断希望要执行哪个具体的方法. HandlerAdapter: 负责调用具体的方法. ViewResovler:视图解析器.解析结果,准备跳转到具体的物理视图 执行流程 1.客户端请求提交到DispatcherServlet2.由DispatcherServlet根据请求路径寻找一个或多个HandlerMapping，找到对应的HandlerAdapter3.由HandlerAdapter执行对应的Controller4.Controller调用业务逻辑，然后返回一个ModelAndView对象5.DispatcherServlet寻找一个或多个ViewResovler视图解析器，找到ModelAndView指定的视图 12345678910111213141516171819202122232425262728293031323334public class DispatcherServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String path=req.getServletPath(); System.out.println(path); if(path.equals(\"/abc\"))&#123; show1(req, resp); &#125; if(path.equals(\"/def\"))&#123; show2(req, resp); &#125; if(path.equals(\"/ddd\"))&#123; show3(req, resp); &#125; if(path.equals(\"/qqqq\"))&#123; show4(req, resp); &#125; &#125; private void show1(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"show1\"); req.getRequestDispatcher(\"/index.jsp\").forward(req,resp); &#125; private void show2(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123; System.out.println(\"show2\"); resp.sendRedirect(\"/login.jsp\"); &#125; private void show3(HttpServletRequest req, HttpServletResponse resp) &#123; System.out.println(\"show3\"); &#125; private void show4(HttpServletRequest req, HttpServletResponse resp) &#123; System.out.println(\"sho4\"); &#125;&#125; 每个show1，show2,……相当于一个Controller原理基本类似，根据请求的路径名来调用对应的Controller这里的if相当于HandlerMapping，只不过人家使用的是map而调用方法不是像这样简单调用，而是通过HandlerAdapter去调用返回请求转发或者重定向是通过ModelAndView和ViewResovler去完成 环境搭建导入相应jar包 基于配置文件的SpringMVC1.在web.xml中部署DispatcherServlet 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--部署DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--springmvc的配置文件 默认在web-inf下 这里重新配置位置 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; DispatcherServlet是基于Servlet的，所以需要在web.xml下进行配置接下来需要配置springmvc的配置文件，如果没有在&lt;servlet&gt;标签下进行配置&lt;init-param&gt;,那么springmvc的配置文件就在WEB_INF下，并且配置文件名字为&lt;servlet-name&gt;的内容加上 - servlet.xml 可以通过&lt;init-param&gt;来配置springmvc的文件 2.创建controller 创建一个实现Controller接口的类 12345678910111213import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class LoginContorller implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; System.out.println(\"LoginContorller\"); return new ModelAndView(\"/login.jsp\"); &#125;&#125; ` 返回值为ModelAndView，默认为请求转发 3.创建springmvc配置文件 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--配置controller--&gt; &lt;bean name=\"login\" class=\"cn.com.controller.LoginContorller\"&gt;&lt;/bean&gt; &lt;!--配置HandlerMapping接口--&gt; &lt;bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt; &lt;property name=\"urlMap\"&gt; &lt;map&gt; &lt;!-- 解析出来控制器逻辑名 --&gt; &lt;!--key为控制器的逻辑名--&gt; &lt;entry key=\"login\" value-ref=\"login\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--配置调用控制器的接口--&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"&gt;&lt;/bean&gt;&lt;/beans&gt; 4.测试index.jsp为测试页面点击登陆后登陆成功 注：上述的配置是没有配置viewResolver的可以配置viewResolver，其作用是在ModelAndView的内容加前缀和后缀 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--配置controller--&gt; &lt;bean name=\"login\" class=\"cn.com.controller.LoginContorller\"&gt;&lt;/bean&gt; &lt;!--配置HandlerMapping接口--&gt; &lt;bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt; &lt;property name=\"urlMap\"&gt; &lt;map&gt; &lt;!-- 解析出来控制器逻辑名 --&gt; &lt;!--key为控制器的逻辑名--&gt; &lt;entry key=\"login\" value-ref=\"login\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--配置调用控制器的接口--&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"&gt;&lt;/bean&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 123456789101112131415package cn.com.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class LoginContorller implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; System.out.println(\"LoginContorller\"); return new ModelAndView(\"login\"); &#125;&#125; 这时ModelAndView的内容可以只写名字，viewResolver将自动添加前缀和后缀 SpringMVC的容器与组件spring的容器是ApplicationContext，SpringMVC的容器是ConfigurableWebApplicationContext ApplicationContext和ConfigurableWebApplicationContext有什么关系？查看ApplicationContext的结构可以看出ApplicationContext有两个子类，而WebApplicatonContext是spirng整合web的容器 接下来就探究springmvc的容器和spring容器的关系 首先，基于spingmvc的原理，首先是要启动DispatcherServlet，而DispatcherServlet是基于serlvet的，所以它必定有init()方法，service()方法，destroy()方法 DispatcherServlet首先来看DispatcherServlet可以看出springmvc将创建自己的配置上下文，基于servlet的init-paraminit-param的ContextConfigLoaction将指示一个被xmlwebapplicationContext加载的xml文件所以可以通过init-param标签指示springmvc的配置文件的位置 1.init()1.在DispatcherServlet的源码里并没有Init()方法，所以找寻它的父类FrameworkServlet2.DispatcherServlet的父类FrameworkServlet也没有Init()方法，继续找寻FrameworkServlet的父类 3.在HttpServletBean有init()方法并且是final的 在init()方法中有个initServletBean的方法，查看结构可以看出实现该方法的有FramworkServlet和ResourceServlet，而FramworkServlet是HttpServletBean的子类所以是调用的FramworkServlet中的initServletBean 4.进入FramworkServlet的initServletBean方法5.进入到initWebApplicationContext方法中getServletContext()获取的是spring容器由WebApplicationContext rootContext=WebApplicationContextUtils.getWebApplicationContext(getServletContext());可以看出spring容器整合为WebApplicationContext 123wac = this.webApplicationContext;if (wac instanceof ConfigurableWebApplicationContext) &#123;ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; 由这三行代码可以看出webApplicationContext强制转换为了ConfigurableWebApplicationContext 1cwac.setParent(rootContext); 由这行代码可以看出ConfigurableWebApplicationContext 的父容器就是webApplicationContext也就是ApplicationContext 所以SpringMVC容器是Spring容器的子容器，SpringMVC容器是可以获取到Spring容器的内容 2.service() 在DispatcherServlet中没有service()方法，所以到其父类FrameworkServlet中找1.可以在FrameworkServlet中找到service()方法2.进入到processRequest在processRequest中调用了doService方法而在frameworkservlet中是一个抽象方法，所以它会调用子类的方法，也就是DispatcherServlet的方法 3.进入DispatcherServlet的doService 4.进入doDispatch查看getHandler方法可以看出是通过HandlerMapping获取Handler 再查看getHandlerAdapter方法返回了对应的HandlerAdapter 继续查看doDispatch可以看出通过handler执行了handle方法，并返回了ModelAndView的一个对象 所以看出springMVC的执行是在DispatcherServlet的doservie()方法中，而不同的类它们的分工是不同的 所以具体流程就是1.客户端请求提交到DispatcherServlet2.由DispatcherServlet根据请求路径寻找一个或多个HandlerMapping，找到对应的HandlerAdapter3.由HandlerAdapter执行对应的Controller4.Controller调用业务逻辑，然后返回一个ModelAndView对象5.DispatcherServlet寻找一个或多个ViewResovler视图解析器，找到ModelAndView指定的视图 HandlerMapping在DispatcherServlet中，通过请求可以获取一个HandlerMapping，而handler是如何找寻到HandlerAdpterHandlerMapping是一个接口，进入一个具体的实现类因为在配置文件中配置的是SimpleUrlHandlerMapping，所以查看SimpleUrlHandlerMapping在实现类中有一个map结构，所以这可以和springmvc配置文件对应起来 12345678910&lt;!--配置HandlerMapping接口--&gt; &lt;bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt; &lt;property name=\"urlMap\"&gt; &lt;map&gt; &lt;!-- 解析出来控制器逻辑名 --&gt; &lt;!--key为控制器的逻辑名--&gt; &lt;entry key=\"login\" value-ref=\"login\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 1.进入其初始化方法2.进入registerHandlers方法enty.getKey()就是配置文件里配置的keyenty.getValue就是配置文件里配置的value 可以看出不管有没有以”/“开头，它都会自动加上 3.进入registerHandler方法可以看出它从spring容器中拿取了对象，对象就是配置文件里的value-ref 接下来就是找寻对应HandlerAdpater,可以看出它是有默认的HandlerAdpater的，在springMVC中，HandlerAdpater和ViewResolver如果没有配置是有默认的 HandlerAdpterHandlerAdpter的方法很简单，DispatcherServlet调用了handle,所以来看handle()方法1.handle()方法 HandlerAdpter是一个接口，所以去看其实现类的接口，因为在配置文件中配置的是SimpleControllerHandlerAdapter，所以查看SimpleControllerHandlerAdapter 它强制转化为了Controller，并调用了Controller的handlerRequest()方法，而自己写的控制器类是实现了Controller接口的 2.进入Controller接口handlerRequest()方法此时查看结构可以看到是有自己写的实现类的，也就是走到这它就去调用了自己写的实现类 基于注解的SpringMVC1.配置web.xml 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--部署DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--springmvc的配置文件 默认在web-inf下 这里重新配置位置 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 2.配置springMVC.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--扫描注解--&gt; &lt;context:component-scan base-package=\"cn.com.controller\"&gt;&lt;/context:component-scan&gt; &lt;!--注解驱动--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;/beans&gt; 3.配置Controller 1234567891011121314package cn.com.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class LoginContorller &#123; @RequestMapping(\"login\") public String login()&#123; System.out.println(\"登陆\"); return \"/login.jsp\"; //如果配置了viewResolver，可以只写一个login &#125;&#125; 在控制器类上配置@Controller 在其处理方法上配置@RequestMapping Controller的参数把内容写到方法参数中,SpringMVC 只要有这个内容就自动注入内容. 基本数据类型1.默认保证参数名称和请求中传递的参数名相同 12345&lt;form action=\"login\" &gt; 姓名：&lt;input name=\"name\" &gt;&lt;/br&gt; 年龄：&lt;input name=\"age\"&gt;&lt;/br&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 写了一个表单 12345678@Controllerpublic class LoginContorller &#123; @RequestMapping(\"login\") public String login(String name,int age)&#123; System.out.println(name+\" \"+age); return \"/login.jsp\"; &#125;&#125; 在方法中获取参数 可以看出是获取到了的 这是因为在请求参数中有name和age,springMVC会根据名称自动进行注入,如果找不到就注入null 12345&lt;form action=\"login\" &gt; 姓名：&lt;input name=\"name11\" &gt;&lt;/br&gt; 年龄：&lt;input name=\"age11\"&gt;&lt;/br&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; 可以看出报错，报错的原因不是找不到，而是因为age是个Int类型，而springmvc无法找到参数内容的话会自动注入null,而nul无法赋值给Int 2.果请求参数名和方法参数名不对应使用@RequestParam()赋 值 12345&lt;form action=\"login\" &gt; 姓名：&lt;input name=\"name11\" &gt;&lt;/br&gt; 年龄：&lt;input name=\"age11\"&gt;&lt;/br&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; 12345678@Controllerpublic class Contorller &#123; @RequestMapping(\"login\") public String login(@RequestParam(\"name11\") String name, @RequestParam(\"age11\") int age)&#123; System.out.println(name+\" \"+age); return \"/login.jsp\"; &#125;&#125; 获取成功 3.@RequestParam 设置默认值. 如果方法参数是基本数据类型(不是封装类)注入Null时会报错，此时可以通过@RequestParam 设置默认值. 12345&lt;form action=\"login\" &gt; 姓名：&lt;input name=\"name11\" &gt;&lt;/br&gt; 年龄：&lt;input name=\"age11\"&gt;&lt;/br&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; 12345678@Controllerpublic class Contorller &#123; @RequestMapping(\"login\") public String login(@RequestParam(defaultValue = \"zhangsan\") String name, @RequestParam(defaultValue =\"20\") int age)&#123; System.out.println(name+\" \"+age); return \"/login.jsp\"; &#125;&#125; 可以看出参数名没有对应，但是没报错，输出默认值 4.强制设置参数 12345678@Controllerpublic class Contorller &#123; @RequestMapping(\"login\") public String login(@RequestParam(required = true) String name, @RequestParam(defaultValue =\"20\") int age)&#123; System.out.println(name+\" \"+age); return \"/login.jsp\"; &#125;&#125; required = true表示必须有参数可以看出直接没有执行到对应的方法 直接在浏览器返回错误，而服务器没有500 参数是对象1.请求参数名和对象属性名相同 12345&lt;form action=\"login\" &gt; 姓名：&lt;input name=\"name\" &gt;&lt;/br&gt; 年龄：&lt;input name=\"age\"&gt;&lt;/br&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; 建立实体类 123456789101112131415161718192021222324252627package cn.com.pojo;public class Student &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 属性和请求参数对应 12345678@Controllerpublic class Contorller &#123; @RequestMapping(\"login\") public String login(Student student)&#123; System.out.println(student); return \"/login.jsp\"; &#125;&#125; 可以看出自动注入值了如果对象的属性和请求参数对应，springMVC自动注入值，调用的是getset方法 2.请求参数包含多个同名参数 12345678&lt;form action=\"login\" &gt; 姓名：&lt;input name=\"name\" &gt;&lt;/br&gt; 年龄：&lt;input name=\"age\"&gt;&lt;/br&gt; 打球&lt;input type=\"checkbox\" name=\"hobby\" value=\"1\"&gt; 绘画 &lt;input type=\"checkbox\" name=\"hobby\" value=2\"&gt; 电影&lt;input type=\"checkbox\" name=\"hobby\" value=\"3\"&gt;&lt;/br&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; hobby是同名参数 12345678@Controllerpublic class Contorller &#123; @RequestMapping(\"login\") public String login(Student student,@RequestParam(\"hobby\") List&lt;String&gt; hobby)&#123; System.out.println(student+\"\"+hobby); return \"/login.jsp\"; &#125;&#125; 使用List获取同名参数，并在前面加上@RequestParam获取成功 3.类中包含对象 123456789101112131415161718192021222324252627package cn.com.pojo;public class Student &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 1234567891011121314151617181920package cn.com.pojo;public class People &#123; private Student student; public Student getStudent() &#123; return student; &#125; public void setStudent(Student student) &#123; this.student = student; &#125; @Override public String toString() &#123; return \"People&#123;\" + \"student=\" + student + '&#125;'; &#125;&#125; 12345678@Controllerpublic class Contorller &#123; @RequestMapping(\"login\") public String login(People people)&#123; System.out.println(people); return \"/login.jsp\"; &#125;&#125; 12345&lt;form action=\"login\" &gt; 姓名：&lt;input name=\"student.name\" &gt;&lt;/br&gt; 年龄：&lt;input name=\"student.age\"&gt;&lt;/br&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; 使用对象名.属性注入值 4.restful传值request获取参数一般都是键值对的形式如 /login?name=xxx&amp;age=xxxx 使用restful方法传值就不是键值对请求格式使用特殊格式 1&lt;a href=\"login/kryie/11\"&gt;跳转&lt;/a&gt; 12345678@Controllerpublic class Contorller &#123; @RequestMapping(\"login/&#123;name&#125;/&#123;age&#125;\") public String login(@PathVariable String name,@PathVariable int age)&#123; System.out.println(name+\" \"+age); return \"/login.jsp\"; &#125;&#125; @RequestMapping 中一定要和请求格式对应{} 中名称自定义名称@PathVariable 获取@RequestMapping 中内容,默认按照 方法参数名称去寻找 @PathVariable(“指定名称”)可以指定去寻找名称 跳转方式SpringMVC默认跳转方式是请求转发. 可以通过设置返回字符串的内容设置跳转方式 12345678@Controllerpublic class Contorller &#123; @RequestMapping(\"login\") public String login(String name,int age)&#123; System.out.println(name+\" \"+age); return \"redirect:/login.jsp\"; &#125;&#125; 重定向 12345678@Controllerpublic class Contorller &#123; @RequestMapping(\"login\") public String login(String name,int age)&#123; System.out.println(name+\" \"+age); return \"forward:/login.jsp\"; &#125;&#125; 请求转发 @ResponseBody在方法上只有@RequestMapping 时,无论方法返回值是什么认为需要跳转 1.普通字符串 .在方法上添加@ResponseBody时，恒不跳转，直接返回对应的值 12345678910@Controllerpublic class Contorller &#123; @RequestMapping(\"login\") @ResponseBody public String login(String name,int age)&#123; System.out.println(name+\" \"+age); return name+\" \"+age; &#125;&#125; 2.返回对象返回值为对象时，@ResponseBody将对象转化为json字符串 在使用@ResponseBody时需要导入jackson的jar包 123456789101112@Controllerpublic class Contorller &#123; @RequestMapping(\"login\") @ResponseBody public Student login()&#123; Student student=new Student(); student.setName(\"Zhangsan\"); student.setAge(11); return student; &#125;&#125; 如果返回值包含中文,出现中文乱码 ,则在RequestMapping中添加属性 1@RequestMapping(value=\"login\",produces=\"application/json; charset=utf-8\") produces 表示响应头中 Content-Type 取值.","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://ReverieZh.github.io/categories/JavaEE/"},{"name":"SpringMVC","slug":"JavaEE/SpringMVC","permalink":"https://ReverieZh.github.io/categories/JavaEE/SpringMVC/"}],"tags":[]},{"title":"","slug":"Spring基础学习","date":"2020-02-20T14:03:07.054Z","updated":"2020-02-22T04:50:23.214Z","comments":true,"path":"2020/02/20/Spring基础学习/","link":"","permalink":"https://ReverieZh.github.io/2020/02/20/Spring基础学习/","excerpt":"Spring简介Spring是分层的JavaSE/EE full-stack 轻量级开源框架，以IoC（Inverse of Control 控制反转）和AOP（Aspect Oriented Programming 面向切面编程）为内核，使用基本的JavaBean来实现程序功能。在实际开发中，通常服务器端采用三层体系架构，分别为表示层(web)、业务逻辑层(service)、持久层(dao)， Spring对每一层都提供了技术支持。","text":"Spring简介Spring是分层的JavaSE/EE full-stack 轻量级开源框架，以IoC（Inverse of Control 控制反转）和AOP（Aspect Oriented Programming 面向切面编程）为内核，使用基本的JavaBean来实现程序功能。在实际开发中，通常服务器端采用三层体系架构，分别为表示层(web)、业务逻辑层(service)、持久层(dao)， Spring对每一层都提供了技术支持。 Spring具有简单、可测试和松耦合的特点，从这个角度出发，Spring不仅可以用于服务器端开发，也可以应用于任何Java应用的开发中。 Spring几大核心功能 1.IoC/DI 控制反转/依赖注入2. AOP 面向切面编程3 声明式事务 上图是spring框架的运行框架一：TestTest：是Spring提供的测试功能 二：Core ContainerCore Container是核心容器，也是Spring提供的最基本的条件 包含： 1.Beans：提供Spring负责创建类对象并管理对象的功能 2.Core：核心类 3.Context：上下文参数。获取外部资源或管理注解等 4.SpEL：是一种强大的表达式语言 三：其他模块AOP模块 ：实现aop功能需要依赖。允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性 Aspects模块 ： 切面 AOP 依赖的包 Instrumentation模块 ：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用 四：Data Access/INtegration(数据访问/集成)模块JDBC模块：Spring 对 JDBC 封装后的代码。提供了一个JDBC的抽象层，大幅度地减少了在开发过程中对数据库操作的代码 ORM模块：封装了持久层框架的代码.例如 Hibernate transactions模块：支持编程和声明式事务管理实现特殊接口类。对应 spring-tx.jar,声明式事务使用 JMS模块：指Java消息服务，包含的功能为生产和消息的信息 五：WEB模块Web模块：提供了基本的web开发集成特性。如：使用的Servlet监听器的IOC容器初始化及web应用上下文 Servlet模块：包括Spring模型-视图-控制器(MVC)实现Web应用程序 Struts模块：包含支持类内的Spring应用程序，集成了经典的Struts Web层 Portlet模块：提供了在portlet环境中使用MVC实现，类似Web-Servlet模块的功能 Web模块:提供了需要 spring 完成 web 相关功能时的功能. 如:由 tomcat 加载 spring 配置文件时需要有 spring-web 包 .Spring 框架中重要概念 容器(Container): Spring 当作一个大容器. 在老版本中是BeanFactory 接口.在新版本中是ApplicationContext 接口,是 BeanFactory 子接 口.BeanFactory 的功能在 ApplicationContext 中都有. 7. 从 Spring3 开始把 Spring 框架的功能拆分成多个 jar. Spring2 及以前就一个 jar 环境搭建导入jar包基本的Spring需要导入的jar包也就是Core模块的相关jar包 另外需要导入Commons-loggging的jar包，是一个第三方的依赖包，主要用于处理日志 配置文件在src下建立applicationContext.xml(文件名称和路径可以自定义)Spring的全局容器ApplicationContext。而applicationContext.xml 配置的信息最终存储到了 AppliationContext 容器中 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;/beans&gt; 使用Spring建立一个实体类 12345678910111213141516171819202122232425262728293031package cn.com.pojo;public class People &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; System.out.println(\"setId\"); this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; System.out.println(\"setName\"); this.name = name; &#125; @Override public String toString() &#123; return \"People&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + '&#125;'; &#125;&#125; 在Spring的配置文件中，配置实体类 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"peo\" class=\"cn.com.pojo.People\"&gt; &lt;/bean&gt;&lt;/beans&gt; 12345678public class Text &#123; public static void main(String[] args) &#123; ApplicationContext context=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); People people=context.getBean(\"peo\", People.class); System.out.println(people); &#125;&#125; 这样的好处，创建对象不用new而是交给Spring，通过&lt;bean/&gt; 创建对象. Spring将创建好的对象放入容器类，而我们只需要从容器中去拿。这就是IOC(控制反转) 默认配置文件被加载时创建对象 IOCIOC(Inversion of Control) 控制反转 IoC 完成的事情原先由程序员主动通过 new 实例化对象事情,转交给 Spring 负责.控制反转中控制指的是:控制类的对象控制反转中反转指的是转交给 Spring 负责. Spring的IOC容器Spring提供了两种IOC容器，分别是BeanFactory和ApplicationContext 在老版本中是BeanFactory 接口.在新版本中是ApplicationContext 接口 1.BeanFactoryBeanFactory是基础类型的IOC容器，由org.springframework.beans.factory.BeanFactory接口定义 BeanFactory提供了完整的IOC服务支持。BeanFactory就是一个管理Bean的工厂，它主要负责初始化各种Bean，并调用它们的生命周期方法创建BeanFactory 实例时，需要提供Spring所管理容器的详细配置信息，这些信息通常采用XML文件形式来管理 1BeanFactory factory=new XmlBeanFactory(new FileSystemResource(\"D:\\\\applicationContext.xml\")); 可以看出XmlBeanFactory已经不推荐使用了 2.ApplicationContextApplicationContext 是BeanFactory的子接口，也称为应用上下文接口。全路径为org.springframework.context.ApplicationContext ApplicationContext不仅提供BeanFactory所有的功能，还以一种面向框架的方式增强BeanFactory的功能。 ApplicationContext接口的实例创建有两种方法1.ClassPathXmlApplicationContext:从类路径的XML文件载入上下文定义信息，把上下文定义文件当作类路径资源 1ApplicationContext context=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 2.FileSystemXml:从文件系统中指定路径的XML文件载入上下文定义信息 1ApplicationContext context= new FileSystemXmlApplicationContext(\"D:\\\\Spring\\src\\applicationContext.xml\") 在老版本中是BeanFactory 接口.在新版本中是ApplicationContext 接口, BeanFactory接口和ApplicationContext接口都是通过XML配置文件加载Bean的，相比之下，ApplicationContext提供更多的扩展功能二者的主要区别是BeanFactory采用的是延迟加载方案，只有在调用getBean()时才会实例化Bean.如果Bean的某一个属性没有注入，使用BeanFactory加载后，在第一次调用getBean()时会抛出异常。而ApplicationContext则在初始化时就一次性创建所有bean,这样有利于所依赖的属性是否注入。 可以看出BeanFactory采用的是延迟加载方案，只有在调用getBean()时才会实例化BeanApplicationContext则在初始化时就一次性创建所有bean Spring 创建对象的三种方式1.通过构造方法创建无参构造创建:默认情况. 12&lt;bean id=\"peo\" class=\"cn.com.pojo.People\"&gt; &lt;/bean&gt; 有参构造创建:需要配置 1234public People(int id, String name) &#123; this.id = id; this.name = name; &#125; 建立有参构造方法 1234&lt;bean id=\"peo\" class=\"cn.com.pojo.People\"&gt; &lt;constructor-arg name=\"id\" value=\"1\"/&gt; &lt;constructor-arg name=\"name\" value=\"张三\"/&gt;&lt;/bean&gt; 使用有参构造方法需要添加&lt;constructor-arg&gt;标签&lt;constructor-arg&gt;标签的 name属性是构造方法的参数名 value属性设立值 除了name属性和value属性还有index属性 ：参数的索引从0开始type属性：声明参数的类型 （需要区分关键字和封装类 如:int和Integer是不同的） 12345678public static void main(String[] args) &#123; ApplicationContext context=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // BeanFactory factory=new XmlBeanFactory(new FileSystemResource(\"D:\\\\applicationContext.xml\")); System.out.println(\"------------获取bean----------------\"); People people=context.getBean(\"peo\", People.class); System.out.println(people); &#125; &#125; 2.实例工厂创建对象工厂设计模式:帮助创建类对象.一个工厂可以生产多个对象 实例工厂:需要先创建工厂,才能生产对象 123456789package cn.com.factory;import cn.com.pojo.People;public class PeopleFactory &#123; public People newInstance()&#123; return new People(11,\"kryie\"); &#125;&#125; 1234&lt;bean id=\"factory\" class=\"cn.com.factory.PeopleFactory\"&gt;&lt;/bean&gt;&lt;bean id=\"peo\" factory-bean=\"factory\" factory-method=\"newInstance\"&gt;&lt;/bean&gt; factory-bean指向factory的bean标签的idfactory-method指向factory中实例化对象的方法名 静态工厂实例化静态工厂:不需要创建工厂,快速创建对象 12345public class PeopleFactory &#123; public static People newInstance()&#123; return new People(11,\"kryie\"); &#125; &#125; 1&lt;bean id=\"peo\" class=\"cn.com.factory.PeopleFactory\" factory-method=\"newInstance\"&gt;&lt;/bean&gt; 通过class属性指定其对应的工厂实现类 Bean 的属性赋值(注入)有参构造可以通过构造方法设置值. 属性setter注入属性为基本数据类型 1234&lt;bean id=\"peo\" class=\"cn.com.pojo.People\"&gt; &lt;property name=\"id\" value=\"11\"/&gt; &lt;property name=\"name\" value=\"kryie\"/&gt;&lt;/bean&gt; 当属性是list类型时 1234567&lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; 当属性是数组时 1234567&lt;property name=\"strs\" &gt; &lt;array&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; 当属性是set时 1234567&lt;property name=\"sets\"&gt; &lt;set&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; 当属性是map时 123456&lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"a\" value=\"b\" &gt; &lt;/entry&gt; &lt;entry key=\"c\" value=\"d\" &gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; 当属性是Properties 类型时 123456&lt;property name=\"demo\"&gt; &lt;props&gt; &lt;prop key=\"key\"&gt;value&lt;/prop&gt; &lt;prop key=\"key1\"&gt;value1&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; 依赖注入(DI)当属性为对象当一个类(A)中需要依赖另一个类()对象时,把 B 赋值给 A 的过 程就叫做依赖注入 1234567891011121314package cn.com.pojo;public class School &#123; private String name; private String address; //省略get和set方法 @Override public String toString() &#123; return \"School&#123;\" + \"name='\" + name + '\\'' + \", address='\" + address + '\\'' + '&#125;'; &#125;&#125; 123456789101112131415public class People &#123; private int id; private String name; private School school; //包含了一个对象 //此处省略get和set方法 @Override public String toString() &#123; return \"People&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", school=\" + school + '&#125;'; &#125; &#125; 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"school\" class=\"cn.com.pojo.School\"&gt; &lt;property name=\"name\" value=\"sust\"/&gt; &lt;property name=\"address\" value=\"xian\"/&gt; &lt;/bean&gt; &lt;bean id=\"peo\" class=\"cn.com.pojo.People\"&gt; &lt;property name=\"id\" value=\"11\"/&gt; &lt;property name=\"name\" value=\"kryie\"/&gt; &lt;property name=\"school\" ref=\"school\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 当属性是对象时，使用ref属性指向其需要实例化bean的id 123456789public static void main(String[] args) &#123; ApplicationContext context=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); System.out.println(\"------------获取bean----------------\"); People people=factory.getBean(\"peo\", People.class); System.out.println(people); System.out.println(people.getSchool().getName()); &#125;&#125;","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://ReverieZh.github.io/categories/JavaEE/"},{"name":"Spring","slug":"JavaEE/Spring","permalink":"https://ReverieZh.github.io/categories/JavaEE/Spring/"}],"tags":[]},{"title":"","slug":"hello-world","date":"2019-10-04T06:46:27.964Z","updated":"2020-02-22T04:50:07.543Z","comments":true,"path":"2019/10/04/hello-world/","link":"","permalink":"https://ReverieZh.github.io/2019/10/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Reverie HelloCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}