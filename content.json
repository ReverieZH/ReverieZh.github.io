{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"ReverieZh","url":"https://ReverieZh.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2019-10-30T08:36:49.000Z","updated":"2020-02-20T15:52:20.272Z","comments":false,"path":"categories/index.html","permalink":"https://ReverieZh.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"Reverie第一篇","date":"2020-02-20T14:03:07.054Z","updated":"2020-02-20T15:59:21.864Z","comments":true,"path":"2020/02/20/Reverie第一篇/","link":"","permalink":"https://ReverieZh.github.io/2020/02/20/Reverie第一篇/","excerpt":"Spring简介Spring是分层的JavaSE/EE full-stack 轻量级开源框架，以IoC（Inverse of Control 控制反转）和AOP（Aspect Oriented Programming 面向切面编程）为内核，使用基本的JavaBean来实现程序功能。在实际开发中，通常服务器端采用三层体系架构，分别为表示层(web)、业务逻辑层(service)、持久层(dao)， Spring对每一层都提供了技术支持。","text":"Spring简介Spring是分层的JavaSE/EE full-stack 轻量级开源框架，以IoC（Inverse of Control 控制反转）和AOP（Aspect Oriented Programming 面向切面编程）为内核，使用基本的JavaBean来实现程序功能。在实际开发中，通常服务器端采用三层体系架构，分别为表示层(web)、业务逻辑层(service)、持久层(dao)， Spring对每一层都提供了技术支持。 Spring具有简单、可测试和松耦合的特点，从这个角度出发，Spring不仅可以用于服务器端开发，也可以应用于任何Java应用的开发中。 Spring几大核心功能 1.IoC/DI 控制反转/依赖注入2. AOP 面向切面编程3 声明式事务 上图是spring框架的运行框架一：TestTest：是Spring提供的测试功能 二：Core ContainerCore Container是核心容器，也是Spring提供的最基本的条件 包含： 1.Beans：提供Spring负责创建类对象并管理对象的功能 2.Core：核心类 3.Context：上下文参数。获取外部资源或管理注解等 4.SpEL：是一种强大的表达式语言 三：其他模块AOP模块 ：实现aop功能需要依赖。允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性 Aspects模块 ： 切面 AOP 依赖的包 Instrumentation模块 ：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用 四：Data Access/INtegration(数据访问/集成)模块JDBC模块：Spring 对 JDBC 封装后的代码。提供了一个JDBC的抽象层，大幅度地减少了在开发过程中对数据库操作的代码 ORM模块：封装了持久层框架的代码.例如 Hibernate transactions模块：支持编程和声明式事务管理实现特殊接口类。对应 spring-tx.jar,声明式事务使用 JMS模块：指Java消息服务，包含的功能为生产和消息的信息 五：WEB模块Web模块：提供了基本的web开发集成特性。如：使用的Servlet监听器的IOC容器初始化及web应用上下文 Servlet模块：包括Spring模型-视图-控制器(MVC)实现Web应用程序 Struts模块：包含支持类内的Spring应用程序，集成了经典的Struts Web层 Portlet模块：提供了在portlet环境中使用MVC实现，类似Web-Servlet模块的功能 Web模块:提供了需要 spring 完成 web 相关功能时的功能. 如:由 tomcat 加载 spring 配置文件时需要有 spring-web 包 .Spring 框架中重要概念 容器(Container): Spring 当作一个大容器. 在老版本中是BeanFactory 接口.在新版本中是ApplicationContext 接口,是 BeanFactory 子接 口.BeanFactory 的功能在 ApplicationContext 中都有. 7. 从 Spring3 开始把 Spring 框架的功能拆分成多个 jar. Spring2 及以前就一个 jar 环境搭建导入jar包基本的Spring需要导入的jar包也就是Core模块的相关jar包 另外需要导入Commons-loggging的jar包，是一个第三方的依赖包，主要用于处理日志 配置文件在src下建立applicationContext.xml(文件名称和路径可以自定义)Spring的全局容器ApplicationContext。而applicationContext.xml 配置的信息最终存储到了 AppliationContext 容器中 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;/beans&gt; 使用Spring建立一个实体类 12345678910111213141516171819202122232425262728293031package cn.com.pojo;public class People &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; System.out.println(\"setId\"); this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; System.out.println(\"setName\"); this.name = name; &#125; @Override public String toString() &#123; return \"People&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + '&#125;'; &#125;&#125; 在Spring的配置文件中，配置实体类 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"peo\" class=\"cn.com.pojo.People\"&gt; &lt;/bean&gt;&lt;/beans&gt; 12345678public class Text &#123; public static void main(String[] args) &#123; ApplicationContext context=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); People people=context.getBean(\"peo\", People.class); System.out.println(people); &#125;&#125; 这样的好处，创建对象不用new而是交给Spring，通过&lt;bean/&gt; 创建对象. Spring将创建好的对象放入容器类，而我们只需要从容器中去拿。这就是IOC(控制反转) 默认配置文件被加载时创建对象 IOCIOC(Inversion of Control) 控制反转 IoC 完成的事情原先由程序员主动通过 new 实例化对象事情,转交给 Spring 负责.控制反转中控制指的是:控制类的对象控制反转中反转指的是转交给 Spring 负责. Spring的IOC容器Spring提供了两种IOC容器，分别是BeanFactory和ApplicationContext 在老版本中是BeanFactory 接口.在新版本中是ApplicationContext 接口 1.BeanFactoryBeanFactory是基础类型的IOC容器，由org.springframework.beans.factory.BeanFactory接口定义 BeanFactory提供了完整的IOC服务支持。BeanFactory就是一个管理Bean的工厂，它主要负责初始化各种Bean，并调用它们的生命周期方法创建BeanFactory 实例时，需要提供Spring所管理容器的详细配置信息，这些信息通常采用XML文件形式来管理 1BeanFactory factory=new XmlBeanFactory(new FileSystemResource(\"D:\\\\applicationContext.xml\")); 可以看出XmlBeanFactory已经不推荐使用了 2.ApplicationContextApplicationContext 是BeanFactory的子接口，也称为应用上下文接口。全路径为org.springframework.context.ApplicationContext ApplicationContext不仅提供BeanFactory所有的功能，还以一种面向框架的方式增强BeanFactory的功能。 ApplicationContext接口的实例创建有两种方法1.ClassPathXmlApplicationContext:从类路径的XML文件载入上下文定义信息，把上下文定义文件当作类路径资源 1ApplicationContext context=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 2.FileSystemXml:从文件系统中指定路径的XML文件载入上下文定义信息 1ApplicationContext context= new FileSystemXmlApplicationContext(\"D:\\\\Spring\\src\\applicationContext.xml\") 在老版本中是BeanFactory 接口.在新版本中是ApplicationContext 接口, BeanFactory接口和ApplicationContext接口都是通过XML配置文件加载Bean的，相比之下，ApplicationContext提供更多的扩展功能二者的主要区别是BeanFactory采用的是延迟加载方案，只有在调用getBean()时才会实例化Bean.如果Bean的某一个属性没有注入，使用BeanFactory加载后，在第一次调用getBean()时会抛出异常。而ApplicationContext则在初始化时就一次性创建所有bean,这样有利于所依赖的属性是否注入。 可以看出BeanFactory采用的是延迟加载方案，只有在调用getBean()时才会实例化BeanApplicationContext则在初始化时就一次性创建所有bean Spring 创建对象的三种方式1.通过构造方法创建无参构造创建:默认情况. 12&lt;bean id=\"peo\" class=\"cn.com.pojo.People\"&gt; &lt;/bean&gt; 有参构造创建:需要配置 1234public People(int id, String name) &#123; this.id = id; this.name = name; &#125; 建立有参构造方法 1234&lt;bean id=\"peo\" class=\"cn.com.pojo.People\"&gt; &lt;constructor-arg name=\"id\" value=\"1\"/&gt; &lt;constructor-arg name=\"name\" value=\"张三\"/&gt;&lt;/bean&gt; 使用有参构造方法需要添加&lt;constructor-arg&gt;标签&lt;constructor-arg&gt;标签的 name属性是构造方法的参数名 value属性设立值 除了name属性和value属性还有index属性 ：参数的索引从0开始type属性：声明参数的类型 （需要区分关键字和封装类 如:int和Integer是不同的） 12345678public static void main(String[] args) &#123; ApplicationContext context=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // BeanFactory factory=new XmlBeanFactory(new FileSystemResource(\"D:\\\\applicationContext.xml\")); System.out.println(\"------------获取bean----------------\"); People people=context.getBean(\"peo\", People.class); System.out.println(people); &#125; &#125; 2.实例工厂创建对象工厂设计模式:帮助创建类对象.一个工厂可以生产多个对象 实例工厂:需要先创建工厂,才能生产对象 123456789package cn.com.factory;import cn.com.pojo.People;public class PeopleFactory &#123; public People newInstance()&#123; return new People(11,\"kryie\"); &#125;&#125; 1234&lt;bean id=\"factory\" class=\"cn.com.factory.PeopleFactory\"&gt;&lt;/bean&gt;&lt;bean id=\"peo\" factory-bean=\"factory\" factory-method=\"newInstance\"&gt;&lt;/bean&gt; factory-bean指向factory的bean标签的idfactory-method指向factory中实例化对象的方法名 静态工厂实例化静态工厂:不需要创建工厂,快速创建对象 12345public class PeopleFactory &#123; public static People newInstance()&#123; return new People(11,\"kryie\"); &#125; &#125; 1&lt;bean id=\"peo\" class=\"cn.com.factory.PeopleFactory\" factory-method=\"newInstance\"&gt;&lt;/bean&gt; 通过class属性指定其对应的工厂实现类 Bean 的属性赋值(注入)有参构造可以通过构造方法设置值. 属性setter注入属性为基本数据类型 1234&lt;bean id=\"peo\" class=\"cn.com.pojo.People\"&gt; &lt;property name=\"id\" value=\"11\"/&gt; &lt;property name=\"name\" value=\"kryie\"/&gt;&lt;/bean&gt; 当属性是list类型时 1234567&lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; 当属性是数组时 1234567&lt;property name=\"strs\" &gt; &lt;array&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; 当属性是set时 1234567&lt;property name=\"sets\"&gt; &lt;set&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; 当属性是map时 123456&lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"a\" value=\"b\" &gt; &lt;/entry&gt; &lt;entry key=\"c\" value=\"d\" &gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; 当属性是Properties 类型时 123456&lt;property name=\"demo\"&gt; &lt;props&gt; &lt;prop key=\"key\"&gt;value&lt;/prop&gt; &lt;prop key=\"key1\"&gt;value1&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; 依赖注入(DI)当属性为对象当一个类(A)中需要依赖另一个类()对象时,把 B 赋值给 A 的过 程就叫做依赖注入 1234567891011121314package cn.com.pojo;public class School &#123; private String name; private String address; //省略get和set方法 @Override public String toString() &#123; return \"School&#123;\" + \"name='\" + name + '\\'' + \", address='\" + address + '\\'' + '&#125;'; &#125;&#125; 123456789101112131415public class People &#123; private int id; private String name; private School school; //包含了一个对象 //此处省略get和set方法 @Override public String toString() &#123; return \"People&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", school=\" + school + '&#125;'; &#125; &#125; 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"school\" class=\"cn.com.pojo.School\"&gt; &lt;property name=\"name\" value=\"sust\"/&gt; &lt;property name=\"address\" value=\"xian\"/&gt; &lt;/bean&gt; &lt;bean id=\"peo\" class=\"cn.com.pojo.People\"&gt; &lt;property name=\"id\" value=\"11\"/&gt; &lt;property name=\"name\" value=\"kryie\"/&gt; &lt;property name=\"school\" ref=\"school\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 当属性是对象时，使用ref属性指向其需要实例化bean的id 123456789public static void main(String[] args) &#123; ApplicationContext context=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); System.out.println(\"------------获取bean----------------\"); People people=factory.getBean(\"peo\", People.class); System.out.println(people); System.out.println(people.getSchool().getName()); &#125;&#125;","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://ReverieZh.github.io/categories/JavaEE/"},{"name":"Spring","slug":"JavaEE/Spring","permalink":"https://ReverieZh.github.io/categories/JavaEE/Spring/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-10-04T06:46:27.964Z","updated":"2020-02-20T12:35:41.907Z","comments":true,"path":"2019/10/04/hello-world/","link":"","permalink":"https://ReverieZh.github.io/2019/10/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Reverie HelloCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}